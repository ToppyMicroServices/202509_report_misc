#!/usr/bin/env python3
"""proc_code01_all_in_one

One-shot runner for the entire proc_code01 flow with fixed paths and no options:
  1) Build JP WAC/WAM quarterly CSV if needed (from firstrow extract)
  2) Build k decomposition for US and JP with auto fallbacks
  3) Trim JP k decomposition (remove trailing all-zero block if any)

US dk_term is stabilized by 4Q trailing moving average (Δk = dk_rate + dk_term preserved).
"""

from __future__ import annotations
from pathlib import Path
import sys, subprocess
import pandas as pd
import numpy as np

ROOT = Path(__file__).resolve().parents[1]
CODE = ROOT / 'code'
RAW  = ROOT / 'data_raw'
PROC = ROOT / 'data_processed'

RAW_US = RAW / 'MORTGAGE30US.csv'
JP_FIRSTROW = PROC / 'jhf_wac_wam_firstrow_extract.csv'
JP_WACWAM   = PROC / 'jp_wac_wam_quarterly_estimated.csv'

OUT_US = PROC / 'proc_code01_k_decomposition_US_quarterly.csv'
OUT_US_RATE_ONLY = PROC / 'proc_code01_k_decomposition_US_quarterly_RATE_ONLY.csv'
OUT_JP = PROC / 'proc_code01_k_decomposition_JP_quarterly.csv'


def ensure_wac_wam():
    if JP_WACWAM.exists():
        print(f"[STEP1][SKIP] WAC/WAM exists: {JP_WACWAM}")
        return True
    if not JP_FIRSTROW.exists():
        print(f"[STEP1][INFO] firstrow not found: {JP_FIRSTROW}")
        return False
    sys.path.insert(0, str(CODE))
    import proc_code01_build_jp_wac_wam_quarterly as wacwam
    ok = wacwam.build(JP_FIRSTROW, JP_WACWAM, include_t=False)
    if ok:
        print(f"[STEP1][OK] WAC/WAM built -> {JP_WACWAM}")
        return True
    return False


def apply_us_term_smoothing_direct(us_df: pd.DataFrame) -> pd.DataFrame:
    """
    Stabilize US dk_term by applying 4Q trailing moving average directly
    on dk_term_raw (no cumulative/diff reconstruction).
    Ensures Δk = dk_rate + dk_term, winsorizes extreme values.
    """
    if us_df.empty:
        return us_df

    us = us_df.sort_values("Date").reset_index(drop=True).copy()
    us["dk_term_raw"] = pd.to_numeric(us.get("dk_term", 0.0), errors="coerce").fillna(0.0)

    # 1) apply trailing 4Q moving average directly
    dk_term_sm = us["dk_term_raw"].rolling(4, min_periods=1).mean()

    # 2) preserve identity
    dk_total   = pd.to_numeric(us["k"], errors="coerce").diff().fillna(0.0)
    dk_rate_sm = dk_total - dk_term_sm

    # 3) winsorize
    dk_term_sm = dk_term_sm.clip(-0.002, 0.002)
    dk_rate_sm = dk_rate_sm.clip(-0.005, 0.005)

    out = us_df.copy()
    out = out.sort_values("Date").reset_index(drop=True)
    out["dk_term"] = dk_term_sm.values
    out["dk_rate"] = dk_rate_sm.values

    print("[STEP2][US] dk_term stabilized by direct 4Q trailing MA; identity Δk preserved.")
    return out


def run_k_decomposition():
    try:
        sys.path.insert(0, str(CODE))
        import proc_code01_build_k_decomposition as kbuild
        rc = kbuild.main()
        if rc == 0:
            print("[STEP2][OK] k decomposition completed (import)")
            return True
    except Exception as e:
        print(f"[STEP2][INFO] external builder not available ({e}); using inlined US builder")

    # If external builder not found, fallback to CSV already generated by fetch_z1 integrated builder
    if OUT_US.exists():
        df = pd.read_csv(OUT_US, parse_dates=["Date"])
        df = apply_us_term_smoothing_direct(df)
        df.to_csv(OUT_US, index=False)
        if OUT_US_RATE_ONLY.exists():
            df2 = df.copy()
            df2["dk_term"] = 0.0
            df2.to_csv(OUT_US_RATE_ONLY, index=False)
        print(f"[STEP2][US] wrote {OUT_US.name}")
        return True
    else:
        print("[STEP2][ERR] US decomposition file not found")
        return False


def trim_jp(eps: float = 0.0):
    if not OUT_JP.exists():
        print(f"[STEP3][SKIP] JP output not found: {OUT_JP}")
        return False
    try:
        df = pd.read_csv(OUT_JP)
        cols = [c for c in ('dk_rate','dk_term','dk_total') if c in df.columns]
        if not cols:
            print("[STEP3][SKIP] no dk_* columns to trim")
            return False
        def is_zero_row(row):
            return all(abs(row[c]) <= eps for c in cols)
        mask_nonzero = ~df.apply(is_zero_row, axis=1)
        if mask_nonzero.any():
            last_nz = mask_nonzero[::-1].idxmax()
            trimmed = df.iloc[:last_nz+1]
            if len(trimmed) < len(df):
                trimmed.to_csv(OUT_JP, index=False)
                print(f"[STEP3][OK] trimmed JP rows {len(df)} -> {len(trimmed)}")
                return True
        print("[STEP3][INFO] no trailing zero block detected")
        return True
    except Exception as e:
        print(f"[STEP3][ERR] trim failed: {e}")
        return False


def main():
    PROC.mkdir(parents=True, exist_ok=True)
    ensure_wac_wam()
    ok2 = run_k_decomposition()
    ok3 = trim_jp(eps=0.0)
    return 0 if ok2 else 1


if __name__ == '__main__':
    raise SystemExit(main())